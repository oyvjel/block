# 
# Cumulus Firewall 
# Copyright (C) 2000  Øyvind Jelstad, Cumulus IT AS
# 
# $Id: block-lib.pl,v 1.6 2003/02/05 02:17:33 oyvind Exp $


package main;

$CFW = "cfw";
$filter = "BLOCK";

sub generate_fw_script {

$log_non_sessions = $config{'log_non_sessions'};


#&header($text{'sgen_title'}, undef, "intro", 1, 1, undef,
#        $text{'author'} ." <BR>" . $text{'homepage'});

   print "<BR><HR><pre>\n";


  $si = ($config{'scriptinterpreter'}) ? $config{'scriptinterpreter'} : "/bin/sh";

  open(FILE, ">$config{'scriptfile'}") || &error($text{'sman_err_write'});
   print FILE "#!$si\n";
   print FILE "# Cumulus IT Blocking  Script File\n";
   print FILE "# Generated by Cumulus Blocklist generator\n";
   print FILE "# Copyright (C) 2000-2002 by Øyvind Jelstad, Cumulus IT AS\n";
   print FILE "# http://www.cumulus.no/\n";
   print FILE "# Created on ", &make_date(time), "\n";



######## INTERFACES ####################################
print FILE "\n\n### Interface addresses ---------------------";
open(IF, " /sbin/ifconfig -a |")  or die "Kan ikke &aring;pne /sbin/ifconfig \n";


while (<IF>) {
   $L=$_;
    if ( $L =~ m/^([a-z0-9:]*) *Link.*/ ) {
#       print "LINE = $L \n";
#	&skriv;
        print FILE "\nADR_$1=`/sbin/ifconfig $1 |sed -n -e \"s/ * inet addr:\\([\.0-9]*\\) .*/\\1/p\"`;";

    }    
}
print FILE "\n\n\n";
close IF;


##########################################################


print FILE <<EOM;


logger -p user.info -t cfw ADMIN: Blocklist installed

#
# Remove all existing rules belonging to this filter
if ! ( $IPTABLES -F BLOCK >/dev/null 2>&1 ) ; 
  then 
  $IPTABLES -N BLOCK
#   echo chain laget; 
  
fi

$IPTABLES -F BLOCK


EOM


######## OPTIONS ###############################################


    $objects = &get_objects;
    $services = &get_objects( "servicefile" );		
    
    $chain = "";

    open(RF, $config{'rulefile'}) || &error($text{'sman_err_read'});  
    $nr = 0;	
    while (<RF>) {
     ( $S,$D,$P,@R ) = split(/,/);
           &script($nr,0, $S,$D,$P,@R );
	$nr++;
    }

print FILE "#Generated from rules:\n",$chain;


#print FILE <<EOM;

## Put reference to Blocklist on top in input chain 
#while ($IPTABLES -L input -n  | grep  BLOCK >/dev/null 2>&1 ) ;
#   do 
#   $IPTABLES -D input -j BLOCK; 
#done

#$IPTABLES -I input -j BLOCK; 

#EOM

close(FILE);

print "<BR><HR></pre>\n";
#&footer("./script_manager.cgi", "Script manager");

}

#######################################################################################
############ Generate chains script for one rule ######################################
sub script {

	my ($nr, $l,$S,$D,$P,@R) = @_;
	($fraction,$log,$tos,$action,$disabled,$comment) = @R;
	if ($disabled){ return;}
	
	if ( $l == 0 ) {        
	   $chain .= "\n# Rule nr $nr: FRA ". $S . " TIL " . $D. " PORT " . $P;
	   $chain .= " Aksjon: $action, Log: $log\n";
	   $chain .= "#------------------------------------------------------------------------------\n";
	}
	
	if ( $l > 10 ) { &error(" Possible object og service group loop, rule $nr "); }
	$src = $objects->{$S};
	if (!$src)  { &error (" Undefined object $S in source, rule $nr"); }
	if ( ref($src) eq  "group" ) {
		foreach my $elem ($src->members) {
			&script($nr, $l+1, $elem,$D,$P,@R );
		 }
	         return;
	}
	$dest = $objects->{$D};
	if (!$dest)  { &error (" Undefined object $D in destination, rule $nr"); }	
	if ( ref($dest) eq  "group" ) {
		foreach my $elem (sort $dest->members) {
			&script($nr, $l+1, $S,$elem,$P,@R );
		 }
	         return;
	}
	$serv = $services->{$P};
       
	if ( ref($serv) eq  "group" ) {
		foreach my $elem ($serv->members) {
			&script($nr, $l+1, $S,$D,$elem,@R );
		 }
	         return;
	}
	if ( $serv ) {
		$proto = $serv->proto;
		$port = $serv->port;
		$sport =$serv->sport; 
		$icmptype = $serv->icmptype;
		$tos = $serv->tos;
	}elsif( ($s = &getservice($P)) != NULL ){
		$proto = $s->{'proto'};
		$port = $s->{'port'};
		$sport =undef;
		$icmptype = undef;
		$tos = undef;
		
	}else{    
		print "WARNING: Service definition not found for proto  $P  in rule nr $nr ( $S -> $D )\n";
		$port = undef;
		$proto= undef;
	}

       if ( $S eq $D ) {
          print "\nWARNING: Source = Destination\n";
	  print "Level $l, Rule nr $nr: FRA ". $S . " TIL " . $D. " PORT " . $P ." ";
	  print "Aksjon: $action, Log: $log ";
	  print " Proto: $proto, Port: $port\n";
	
#	    return;
	}
###########################
# Her har vi en enkelt service, source og dest. Generer Input, forward og output 
	($s_if_n,$s_if) = split(/,/, $src->location);
	($d_if_n,$d_if) = split(/,/, $dest->location);
	$MASQIP = "INVALID";

    $chain .= "\n# Rule nr $nr: FRA ". $S ." on |".$s_if_n . "| TIL " . $D ." on |".$d_if_n . "| PORT " . $P ."\n";

    $d_is_FW = $s_is_FW = undef; 
    if ( $src->type eq "interface" ) {
        $s_is_FW = true;
	$chain .= "# SOURCE IS FIREWALL!\n";
	if ( $src->ip eq "0.0.0.0" ){
	      $src->ip('$ADR_'.$s_if);
	}
    }
    
    if ( $dest->type eq "interface" ) {
        $d_is_FW = true;
	$chain .= "# DESTINATION IS FIREWALL!\n";
	if ( $dest->ip eq "0.0.0.0" ){
	      $dest->ip('$ADR_'.$d_if);
	}
    }
    
    
    if ( ($action eq "ACCEPT") || ($action eq "MASQ" )) {
          print "\nWARNING: BLOCK will not create $action rules. SKIPPED\n";
	  return;
	  
    } else { # reject | return...
	if ($action eq "DENY") {$action="DROP"};
	if ( $d_is_FW ){ $d_if=undef;}
	if ( $s_is_FW ){ $s_if=undef;}

	$line = "$IPTABLES -A BLOCK ";
	$line .=&chain_param($s_if,$src->ip,$src->netmask,$sport,$d_if,$dest->ip,$dest->netmask,$proto,$port,$icmptype); 

	if ( $log ) {
	    $chain .= $line ." -j LOG --log-prefix \"$CFW:$filter:$action RULE=$nr \"\n";	
	}

	$line .=" -j ". $action;

        $chain .= $line ."\n";
	

	
	
    }
	


#	print @R;
}

sub  OLD_add_reply {

my ($ch, $if,$sip,$snetmask,$sport,$dip,$dnetmask,$proto,$port,$icmptype) = @_;

        $ret = "$IPTABLES -A ". $ch ." ";

	if( $proto eq "tcp" ) {
	   $ret = "$IPTABLES -I ". $ch ." ";
	}
	
	if( ($proto eq "tcp") ||($proto eq "udp") ) {	
	   $chain .= "# Accept reply  $ch  on  IF $if\n";
           $ret .=&chain_param($if,$sip,$snetmask,$sport,$dip,$dnetmask,$proto,$port,$icmptype);
	   if ($proto eq "tcp"){ $ret .= " ! -y"; } 
	   $chain .= $ret ." -j ACCEPT\n";

        }
	if (( $proto eq "tcp") &&   &checkport($sport,21) ) { # ftp
	   $chain .="# ADDING FTP data channel \n";
	   $ret = "$IPTABLES -I ". $ch ." ";
           $ret .=&chain_param($if,$sip,$snetmask,20,$dip,$dnetmask,$proto,"1024:",undef);
	   $chain .= $ret ." -j ACCEPT\n";
	   
	}
}	

sub OLD_checkport  {
   my ($port, $cp ) = @_;

   my $f,$t;
   if ($port eq $cp ) { return $cp;}
   if ( !$port ) { return $cp;}
   
   if ( $port =~ m/(\d*):(\d*)/ ) {
      $f = ($1) ? $1 : 0;
      $t = ($2) ? $2 : 65535;
#print  " Fra = $f, Til = $t \n";   
       if ( (int($f) <= int($cp)) && ( int($cp) <= int($t)) ) { return $cp; }
   }
#print " Ikke funnet \n";   
   return undef;
   
}

sub chain_param {
	local ($s_if,$src_ip,$src_mask,$sport,$d_if,$dest_ip,$dest_mask,$proto,$port,$icmptype) = @_; 
	local $line = "";
	
	$line .= "-i $s_if " if ($s_if); 
    	$line .= "-o $d_if " if ($d_if); 
	$line .= ($src_ip) ? "-s ". $src_ip :"" ;
	$line .= ($src_mask) ? "/". $src_mask :"" ;
	
#        $line .=" -d ". $dest->ip ."/". $dest->netmask;
	$line .= ($dest_ip) ? " -d ". $dest_ip :"" ;
	$line .= ($dest_mask) ? "/". $dest_mask :"" ;


	if( ($proto eq "tcp") ||($proto eq "udp") ) {
           $line .= " -p ". $proto . " --destination-port ". $port;
	    if( $sport ){  $line .= " --source-port ". $sport;}
	}
	elsif( $proto eq "icmp" ) {
	    $line .= " -p icmp ";
	    if ( $icmptype ) { $line .= " --icmp-type " . $icmptype;}
	}

	elsif( ! $proto  ) {
	    }
	elsif( $proto ne "Any" ) {
	    $line .= " -p ". $proto;
	}
	

#	if ( $tos ne "" ) {
#            $line .= " -t 0x01 ". $tos;
#	}

#Merking av pakker/regler med regelnummer.	
#	$line .= " -m ". $nr;
	return $line;
}

    
    
sub OLD_chain_param {
	local ($s_if,$src_ip,$src_mask,$sport,$dest_ip,$dest_mask,$proto,$port,$icmptype) = @_; 
	local $line = "";
	
	$line .= "-i $s_if " if ($s_if); 
	$line .= ($src_ip) ? "-s ". $src_ip :"" ;
	$line .= ($src_mask) ? "/". $src_mask :"" ;
	
	if( $sport && (($proto eq "tcp") ||($proto eq "udp")) ){  $line .= " ". $sport;}
#        $line .=" -d ". $dest->ip ."/". $dest->netmask;
	$line .= ($dest_ip) ? " -d ". $dest_ip :"" ;
	$line .= ($dest_mask) ? "/". $dest_mask :"" ;


	if( ($proto eq "tcp") ||($proto eq "udp") ) {
           $line .= " ". $port ." -p ". $proto;
	}
	elsif( $proto eq "icmp" ) {
	    $line .= " -p icmp ";
	    if ( $icmptype ) { $line .= " --icmp-type " . $icmptype;}
	}
	elsif( $proto ne "Any" ) {
	    $line .= " -p ". $proto;
	}
	return $line;
}

sub getservice {
  my $n = shift;
  $n=~ /([^\/]+)\/?(.*)/;
   my $name= $1;
  my $proto = $2 ? $2 : "undef";
# print "Name: $name ,Proto: $proto \n";
 my @sl = &get_services;
    for $s (@sl){
	if( $s->{'name'} eq $name && ($s->{'proto'} eq $proto || $proto eq "undef" ) ) {
#	  print " Proto  $s->{'name'} ,$s->{'proto'}  found \n";	
	    return $s; 
	} 
    }
print " ERROR: service $n not found\n ";    
return FALSE;
 
}

sub trans {
   my $l = shift;

   if ( $text{$l} ){
      return $text{$l};
   }

   return $l . "(Undefined translation)";
}


sub if_ip {
   my $if = shift;
#   my %objects = @_;
   if ( !$objects) { $objects = &get_objects;}
   @sok =  keys %$objects;
    foreach $on (@sok) {
         $o = $objects->{$on};
	 if ( ($o->type eq "interface") && ( $o->location eq $if ))  { return $o->ip ."/".$o->netmask; }
    }
   
    &error (" Undefined object for interface $if "); 	
}

1;
